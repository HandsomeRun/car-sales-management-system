# 汽车销售管理系统 - 并发设计文档

**文档版本**: v1.0  
**编写人**: 常润（架构师）  
**编写日期**: 2025-10-16  
**PingCode工作项**: [PING-002]

---

## 1. 并发需求分析

### 1.1 需求背景

根据项目指标要求，系统需要在**极端情况下支持 10,000 个用户同时使用**。

### 1.2 并发场景

1. **高并发查询** - 多个用户同时浏览汽车列表
2. **高并发下单** - 多个用户同时创建订单
3. **高并发写入** - 管理员同时更新多个汽车信息

---

## 2. 并发设计目标

| 指标 | 目标值 | 说明 |
|-----|--------|------|
| 并发用户数 | 10,000+ | 同时在线用户数 |
| 请求响应时间 | < 100ms | 内存操作，极快响应 |
| 限流保护 | 1000 req/s/IP | 防止单一IP恶意攻击 |
| 系统可用性 | > 99.5% | 错误处理和降级机制 |

---

## 3. 并发控制策略（简化方案）

由于本项目采用**简化实现**，使用内存数组模拟数据库，因此并发设计也相应简化，但仍然展示完整的设计思想。

### 3.1 架构层面

```
┌────────────────────────────────────────────────────┐
│               客户端（10,000+ 用户）                │
└──────────────────┬─────────────────────────────────┘
                   │
┌──────────────────▼─────────────────────────────────┐
│            中间件：限流器（RateLimiter）            │
│   算法：滑动时间窗口 + IP 计数器                    │
│   限制：1000 请求/秒/IP                            │
└──────────────────┬─────────────────────────────────┘
                   │
┌──────────────────▼─────────────────────────────────┐
│                路由层（Router）                     │
│         请求分发，负载自动分散                      │
└──────────────────┬─────────────────────────────────┘
                   │
┌──────────────────▼─────────────────────────────────┐
│              业务逻辑层（Service）                  │
│       Node.js 单线程，异步非阻塞处理                │
└──────────────────┬─────────────────────────────────┘
                   │
┌──────────────────▼─────────────────────────────────┐
│            数据访问层（DAO）                        │
│       内存数组操作（O(n) 查询，O(1) 追加）          │
└────────────────────────────────────────────────────┘
```

---

## 4. 限流算法设计

### 4.1 滑动时间窗口算法

**原理**：
- 维护一个 Map，存储每个 IP 的请求记录
- 每次请求检查时间窗口内的请求数
- 超过限制则拒绝请求

**数据结构**：

```typescript
interface RequestRecord {
  count: number;           // 请求次数
  windowStart: number;     // 时间窗口起始时间（毫秒）
}

class RateLimiter {
  private records: Map<string, RequestRecord> = new Map();
  private readonly limit: number = 1000;        // 每秒最大请求数
  private readonly windowSize: number = 1000;   // 时间窗口（毫秒）
}
```

### 4.2 算法流程

```
请求到达
    │
    ▼
获取客户端IP
    │
    ▼
检查 Map 中是否有该 IP 的记录
    │
    ├──► 无记录：创建新记录，允许请求
    │
    └──► 有记录
           │
           ▼
      计算时间差
           │
           ├──► 超过窗口时间：重置计数器，允许请求
           │
           └──► 在窗口内
                  │
                  ▼
             检查请求次数
                  │
                  ├──► count < limit：计数+1，允许请求
                  │
                  └──► count >= limit：拒绝请求（429 Too Many Requests）
```

### 4.3 代码实现（简化版）

```typescript
export class RateLimiter {
  private records = new Map<string, RequestRecord>();
  private readonly limit = 1000;      // 每秒1000请求
  private readonly windowSize = 1000; // 1秒窗口

  public checkLimit(ip: string): boolean {
    const now = Date.now();
    const record = this.records.get(ip);

    if (!record) {
      // 首次请求
      this.records.set(ip, { count: 1, windowStart: now });
      return true;
    }

    const timeDiff = now - record.windowStart;

    if (timeDiff > this.windowSize) {
      // 超过时间窗口，重置
      this.records.set(ip, { count: 1, windowStart: now });
      return true;
    }

    // 在时间窗口内
    if (record.count < this.limit) {
      record.count++;
      return true;
    }

    // 超过限制
    return false;
  }
}
```

---

## 5. 数据并发控制

### 5.1 读并发

**场景**：10,000 个用户同时查询汽车列表

**处理方式**：
- 内存数组读取，无锁设计
- Node.js 单线程 + 事件循环，自动处理并发
- 读操作不修改数据，天然并发安全

**性能分析**：
```
查询操作：O(n)，n 为汽车数量
响应时间：< 10ms（内存读取）
并发能力：10,000+ 并发读
```

### 5.2 写并发

**场景**：多个用户同时创建订单

**处理方式**：
- Node.js 单线程，写操作自动串行化
- Array.push() 操作原子性保证
- 无需额外加锁

**简化说明**：
本项目使用内存数组，Node.js 单线程模型天然避免了并发写冲突。在真实生产环境中，应该使用：
- 数据库事务（ACID）
- 乐观锁/悲观锁
- 分布式锁（Redis）

---

## 6. Node.js 并发优势

### 6.1 事件驱动 + 非阻塞 I/O

```
                   ┌───────────────┐
                   │  Event Loop   │
                   └───────┬───────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
    ┌───▼───┐          ┌───▼───┐          ┌───▼───┐
    │ 请求1  │          │ 请求2  │          │ 请求3  │
    │处理中  │          │等待IO  │          │处理中  │
    └───┬───┘          └───────┘          └───┬───┘
        │                                      │
        └──────────────┬───────────────────────┘
                       │
                  ┌────▼────┐
                  │  响应    │
                  └─────────┘
```

**优势**：
- 单线程无锁，避免线程切换开销
- 异步非阻塞，高效处理 I/O
- 适合高并发、低 CPU 计算场景

### 6.2 并发能力测试（理论值）

| 场景 | 并发数 | 响应时间 | 说明 |
|-----|--------|---------|------|
| 纯内存读取 | 10,000+ | < 10ms | 无 I/O 阻塞 |
| 内存写入 | 10,000+ | < 50ms | Array.push() |
| 限流保护 | 1,000 req/s/IP | - | 防止滥用 |

---

## 7. 性能优化策略

### 7.1 内存优化

**策略**：
1. 使用 TypeScript 强类型，减少运行时类型检查
2. 避免深拷贝，使用引用传递
3. 定期清理过期的限流记录

```typescript
// 定期清理限流记录
setInterval(() => {
  const now = Date.now();
  this.records.forEach((record, ip) => {
    if (now - record.windowStart > this.windowSize * 10) {
      this.records.delete(ip);
    }
  });
}, 60000); // 每分钟清理一次
```

### 7.2 查询优化

**策略**：
1. 热点数据缓存（前 100 条汽车）
2. 分页查询，减少单次返回数据量
3. 索引模拟（使用 Map 存储 ID 映射）

```typescript
// ID 索引
private carIndex = new Map<string, Car>();

// O(1) 查询
public findById(id: string): Car | null {
  return this.carIndex.get(id) || null;
}
```

---

## 8. 并发测试方案

### 8.1 单元测试

**测试用例**：
```typescript
// tests/unit/RateLimiter.test.ts
test('限流器：100次请求应该通过', () => {
  const limiter = new RateLimiter();
  for (let i = 0; i < 100; i++) {
    assert.strictEqual(limiter.checkLimit('127.0.0.1'), true);
  }
});

test('限流器：1001次请求应该被拒绝', () => {
  const limiter = new RateLimiter();
  for (let i = 0; i < 1000; i++) {
    limiter.checkLimit('127.0.0.1');
  }
  assert.strictEqual(limiter.checkLimit('127.0.0.1'), false);
});
```

### 8.2 压力测试（可选）

**工具**：Apache JMeter

**测试场景**：
- 模拟 10,000 并发用户
- 每秒 10,000 请求
- 持续 60 秒

**预期结果**：
- 响应时间 < 100ms
- 错误率 < 0.1%
- 限流器正常工作

---

## 9. 生产环境扩展建议

虽然本项目采用简化实现，但在真实生产环境中应考虑：

### 9.1 数据库层面

```
┌─────────────────────────────────────┐
│         负载均衡（Nginx）            │
└──────────┬──────────────────────────┘
           │
    ┌──────┴──────┐
    │             │
┌───▼───┐     ┌───▼───┐
│Node.js│     │Node.js│   应用服务器集群
│ 实例1  │     │ 实例2  │
└───┬───┘     └───┬───┘
    │             │
    └──────┬──────┘
           │
    ┌──────▼──────┐
    │ MySQL 主库   │  数据库主从
    │（写）        │
    └──────┬──────┘
           │
    ┌──────┴──────┐
    │             │
┌───▼───┐     ┌───▼───┐
│从库1   │     │从库2   │  读写分离
│（读）  │     │（读）  │
└───────┘     └───────┘
```

### 9.2 缓存层面

```
┌─────────────────────────────────────┐
│         Redis 集群                  │
│  - 热点数据缓存                      │
│  - 分布式锁                         │
│  - 限流计数器                       │
└─────────────────────────────────────┘
```

### 9.3 消息队列

```
┌─────────────────────────────────────┐
│      RabbitMQ / Kafka               │
│  - 异步处理订单                      │
│  - 削峰填谷                         │
│  - 解耦服务                         │
└─────────────────────────────────────┘
```

---

## 10. 总结

### 10.1 简化方案的合理性

本项目采用**内存数组 + 限流器**的简化方案，符合以下实际需求：

1. **教学目的** - 重在展示项目管理和协同开发流程
2. **快速演示** - 无需配置数据库，npm start 即可运行
3. **设计完整** - 虽然简化，但设计思想完整
4. **可扩展性** - 架构清晰，易于扩展为生产级系统

### 10.2 并发设计亮点

- ✅ 滑动时间窗口限流算法
- ✅ Node.js 天然并发优势
- ✅ 分层架构，职责分离
- ✅ 完整的并发测试方案

### 10.3 满足指标要求

| 指标 | 要求 | 实现方式 |
|-----|------|---------|
| 并发用户数 | 10,000 | Node.js 事件循环 + 限流保护 |
| 响应时间 | < 2s | 内存操作 < 100ms |
| 可用性 | > 99.5% | 错误处理 + 限流保护 |

---

**文档变更历史**：

| 版本 | 日期 | 修改人 | 修改内容 |
|-----|------|--------|---------|
| v1.0 | 2025-10-16 | 常润 | 初始版本 |

